{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simplified Algorithm for a Modern Implementation of the PID Law \u00b6 The PID law is still largely misunderstood. Some classify it as a simple and old control algorithm. However, the PID law is the simplest representation of active inference in nature. It is the simplest representation of the complex intelligence of inference in nature. The PID law, actively tries to minimize the deviation of the sensed behaviour from the expected behaviour. It is a law for making inference based on an expected behaviour, and a sensed behaviour. This means that the PID law is artificial intelligence (AI) for inference. Notably, Nicolai Minorsky realised this in the early nineties. It is clear that the representation of this AI is still far from mature. In systems and control, this law is used as an algorithm for robust feedback control. It infers the necessary control input u u to a dynamical system, to reach an achievable expected output r r of the dynamical system Two main problems in this AI exist. The representation, and the design of AI. Research in the control literature has mostly focused on the latter. Synopsis In this library, we provide for practical use, a simple but robust realization of the PID law represented in critic form. The features implemented are compactly listed in the about page. The problem of automatic design of the PID law for control is approached from the viewpoint of the 'closed PID-loop model'. For a more technical understanding of this automatic tuning design, read the preprint at ( https://arxiv.org/pdf/2006.00314 ). Also, please see the library license for further details on library use. PID Law: Representation \u00b6 The PID Law can be represented as a critic function: u = f(r,y) u = f(r,y) $$ u=f(r,y)=\\lambda_p\\,u_p + \\lambda_i\\,u_i + \\lambda_d\\,u_d $$ Usecase \u00b6 The tuning method included in this library as default is the CPLMFC. The process is illustrated as shown: Initializations \u00b6 C++ #include \"Arduino.h\" /* PID Library Include Files */ #include \"ModernPIDControlSS.h\" /* Global Declarations */ /* Tuning Parameters */ double wn ; float alpha ; /* Timing Information */ double L ; double ts ; double dt = 0.01 ; double t = 0.0 ; const double r = 150.0 ; double y = 0 ; int countseq = 0 ; const int umin = - 255 ; const int umax = 255 ; const int dead_max = 100 ; const int dead_min = 10 ; // zero tolerance limits /* Parameters PID Structure Config. */ PIDNet PIDobj_II ( r , y , dt , umax , umin ); Setup \u00b6 C++ void setup () { // Turn on Serial Comms. // 9600 baud is a compromise setting for easy killing of a runaway process // and very slow process Serial . begin ( 9600 ); // Can Go Up to 2M PIDobj_II . Ts = dt ; /* Parameters PID Structure Config. */ PIDobj_II . b = 1 ; // optional PIDobj_II . c = 0 ; // optional PIDobj_II . follow = 1 ; // optional /* CPLMFC Tuning HyperParameter Config. */ int Nts = 228 ; // settling horizon: set after settling-time identification ts = Nts * dt ; // settling time (including delay time) L = 0 * dt ; // estimated transport or delay time /* Hyper-Parameter for Kp and Critic Weights */ alpha = 20.0 ; // for P // for D PIDobj_II . lambdad = 0.1 ; // I PIDobj_II . lambdai = 0.5 ; /* PID Commonsense Model Config. */ /* Natural Frequency for PID Commonsense */ tuneWn ( PIDobj_II , ts , wn ); //Serial.println(wn);// debug } Settling-Time Identification Loop \u00b6 C++ ... /* SYS ID- START */ if ( sys_id == 1 ) { if ( countseq == 0 ) { ref_id = 1 * 255 ; PIDobj_II . y = 1 * 255 ; } PIDobj_II . u = ref_id - PIDobj_II . y ; // SYS ID- END } ... PID-Control Loop \u00b6 C++ ... tstart = micros () / double ( 1000000 ); t = t - tstart ; if ( t >= ( ( PIDobj_II . T_prev + PIDobj_II . Ts ) - ( 0.5 * PIDobj_II . Ts ) )) { /* CPLM Evolution */ cplm_kernel ( PIDobj_II . ym , PIDobj_II . xm , PIDobj_II . r , PIDobj_II . Ts , 0 , 0 , wn ); // Serial.print(\"ym: \"); Serial.println(PIDobj_II.ym); /* CPLMFC Tuning Computation */ tuneKp ( PIDobj_II , t , L , ts , alpha , 2 ); //Serial.print(\"Kp: \");Serial.println(PIDobj_II.Kp); tuneKi ( PIDobj_II , wn ); //Serial.print(\" Ki: \");Serial.print(PIDobj_II.Ki); tuneKd ( PIDobj_II , wn ); //Serial.print(\" Kd: \");Serial.println(PIDobj_II.Kd); /* PID Control State Evolution: Architecture */ sfunPID_kernel ( PIDobj_II , t ); //Serial.print(\"upwm_II: \"); Serial.println(PIDobj_II.u); } t = micros () / double ( 1000000 ); ... Notice \u00b6 Please, this Guide is still a draft (beta). It will be updated gradually. Faq Please, feel free to contact me at oasomefun@futa.edu.ng for any questions or to report any bug.","title":"Guide"},{"location":"#simplified-algorithm-for-a-modern-implementation-of-the-pid-law","text":"The PID law is still largely misunderstood. Some classify it as a simple and old control algorithm. However, the PID law is the simplest representation of active inference in nature. It is the simplest representation of the complex intelligence of inference in nature. The PID law, actively tries to minimize the deviation of the sensed behaviour from the expected behaviour. It is a law for making inference based on an expected behaviour, and a sensed behaviour. This means that the PID law is artificial intelligence (AI) for inference. Notably, Nicolai Minorsky realised this in the early nineties. It is clear that the representation of this AI is still far from mature. In systems and control, this law is used as an algorithm for robust feedback control. It infers the necessary control input u u to a dynamical system, to reach an achievable expected output r r of the dynamical system Two main problems in this AI exist. The representation, and the design of AI. Research in the control literature has mostly focused on the latter. Synopsis In this library, we provide for practical use, a simple but robust realization of the PID law represented in critic form. The features implemented are compactly listed in the about page. The problem of automatic design of the PID law for control is approached from the viewpoint of the 'closed PID-loop model'. For a more technical understanding of this automatic tuning design, read the preprint at ( https://arxiv.org/pdf/2006.00314 ). Also, please see the library license for further details on library use.","title":"Simplified Algorithm for a Modern Implementation of the PID Law"},{"location":"#pid-law-representation","text":"The PID Law can be represented as a critic function: u = f(r,y) u = f(r,y) $$ u=f(r,y)=\\lambda_p\\,u_p + \\lambda_i\\,u_i + \\lambda_d\\,u_d $$","title":"PID Law: Representation"},{"location":"#usecase","text":"The tuning method included in this library as default is the CPLMFC. The process is illustrated as shown:","title":"Usecase"},{"location":"#initializations","text":"C++ #include \"Arduino.h\" /* PID Library Include Files */ #include \"ModernPIDControlSS.h\" /* Global Declarations */ /* Tuning Parameters */ double wn ; float alpha ; /* Timing Information */ double L ; double ts ; double dt = 0.01 ; double t = 0.0 ; const double r = 150.0 ; double y = 0 ; int countseq = 0 ; const int umin = - 255 ; const int umax = 255 ; const int dead_max = 100 ; const int dead_min = 10 ; // zero tolerance limits /* Parameters PID Structure Config. */ PIDNet PIDobj_II ( r , y , dt , umax , umin );","title":"Initializations"},{"location":"#setup","text":"C++ void setup () { // Turn on Serial Comms. // 9600 baud is a compromise setting for easy killing of a runaway process // and very slow process Serial . begin ( 9600 ); // Can Go Up to 2M PIDobj_II . Ts = dt ; /* Parameters PID Structure Config. */ PIDobj_II . b = 1 ; // optional PIDobj_II . c = 0 ; // optional PIDobj_II . follow = 1 ; // optional /* CPLMFC Tuning HyperParameter Config. */ int Nts = 228 ; // settling horizon: set after settling-time identification ts = Nts * dt ; // settling time (including delay time) L = 0 * dt ; // estimated transport or delay time /* Hyper-Parameter for Kp and Critic Weights */ alpha = 20.0 ; // for P // for D PIDobj_II . lambdad = 0.1 ; // I PIDobj_II . lambdai = 0.5 ; /* PID Commonsense Model Config. */ /* Natural Frequency for PID Commonsense */ tuneWn ( PIDobj_II , ts , wn ); //Serial.println(wn);// debug }","title":"Setup"},{"location":"#settling-time-identification-loop","text":"C++ ... /* SYS ID- START */ if ( sys_id == 1 ) { if ( countseq == 0 ) { ref_id = 1 * 255 ; PIDobj_II . y = 1 * 255 ; } PIDobj_II . u = ref_id - PIDobj_II . y ; // SYS ID- END } ...","title":"Settling-Time Identification Loop"},{"location":"#pid-control-loop","text":"C++ ... tstart = micros () / double ( 1000000 ); t = t - tstart ; if ( t >= ( ( PIDobj_II . T_prev + PIDobj_II . Ts ) - ( 0.5 * PIDobj_II . Ts ) )) { /* CPLM Evolution */ cplm_kernel ( PIDobj_II . ym , PIDobj_II . xm , PIDobj_II . r , PIDobj_II . Ts , 0 , 0 , wn ); // Serial.print(\"ym: \"); Serial.println(PIDobj_II.ym); /* CPLMFC Tuning Computation */ tuneKp ( PIDobj_II , t , L , ts , alpha , 2 ); //Serial.print(\"Kp: \");Serial.println(PIDobj_II.Kp); tuneKi ( PIDobj_II , wn ); //Serial.print(\" Ki: \");Serial.print(PIDobj_II.Ki); tuneKd ( PIDobj_II , wn ); //Serial.print(\" Kd: \");Serial.println(PIDobj_II.Kd); /* PID Control State Evolution: Architecture */ sfunPID_kernel ( PIDobj_II , t ); //Serial.print(\"upwm_II: \"); Serial.println(PIDobj_II.u); } t = micros () / double ( 1000000 ); ...","title":"PID-Control Loop"},{"location":"#notice","text":"Please, this Guide is still a draft (beta). It will be updated gradually. Faq Please, feel free to contact me at oasomefun@futa.edu.ng for any questions or to report any bug.","title":"Notice"},{"location":"about/","text":"About \u00b6 This realization of the PID control algorithm has all the practical problems of PID control implementation, internally addressed in the PID algorithm itself. It features: Simplified Bilinear Discretization for Integration and Differentiation Filtering: Information theory perspective of Signal processing Critic Contributions Two Degree-of-Freedom Control Structure Automatic Anti-windup Control Real-time Tuning: Closed PID-Loop Model Following Control Closed PID-Loop Model Following Control \u00b6 Closed PID-Loop Model Following Control is the method used to tune the PID is detailed in this paper CPLMFC . For more details on the theory, see Closed PID-Loop Model Following Control Preprint .","title":"About"},{"location":"about/#about","text":"This realization of the PID control algorithm has all the practical problems of PID control implementation, internally addressed in the PID algorithm itself. It features: Simplified Bilinear Discretization for Integration and Differentiation Filtering: Information theory perspective of Signal processing Critic Contributions Two Degree-of-Freedom Control Structure Automatic Anti-windup Control Real-time Tuning: Closed PID-Loop Model Following Control","title":"About"},{"location":"about/#closed-pid-loop-model-following-control","text":"Closed PID-Loop Model Following Control is the method used to tune the PID is detailed in this paper CPLMFC . For more details on the theory, see Closed PID-Loop Model Following Control Preprint .","title":"Closed PID-Loop Model Following Control"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2020-20xx Oluwasegun Somefun oasomefun@futa.edu.ng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2020-20xx Oluwasegun Somefun oasomefun@futa.edu.ng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}