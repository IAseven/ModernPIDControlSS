{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"guide/","text":"Simplified Algorithm for a Modern Implementation of the PID Law \u00b6 Although, the concept and theory of the PID is considered established by many, yet the PID law is still largely misunderstood. It is usually under-rated as a simple and old control algorithm. Quite truly, the overview representation is simple, but its design is not so. From the lens of neuroscience, the PID law is the simplest representation of active inference in nature. It is the simplest representation of the complex intelligence of inference in nature. The PID law, actively tries to minimize the deviation of the sensed behaviour from the expected behaviour. It is a law for making inference based on an expected behaviour, and a sensed behaviour. This means that the PID law is an artificial intelligence (AI) for inference. Notably, Nicolai Minorsky, who proposed the seminal theoretical representation of the PID realised this in the early nineties. An important design question is: how to represent this AI and its parameters for guaranteed stable inference (control). In systems and control, this law is used as an algorithm for robust feedback control. It infers the necessary control input u u to a dynamical system, to reach an achievable expected output r r of the dynamical system Two main problems in this AI exist. The representation, and the design of AI. Research in the control literature has mostly focused on the latter. Synopsis In this library, using modern control theory, we provide for practical use, a simple but robust realization of the PID law represented in critic form. The features implemented are compactly listed in the about page. The problem of automatic design of the PID law for control is approached from the viewpoint of the 'closed PID-loop model'. For a more technical understanding of this automatic tuning design, read the preprint at ( https://arxiv.org/pdf/2006.00314 ). Also, please see the library license for further details on library use. PID Law: Representation \u00b6 The PID Law can be represented as a critic function: u = f(r,y) u = f(r,y) $$ u=f(r,y)=\\lambda_p\\,u_p + \\lambda_i\\,u_i + \\lambda_d\\,u_d $$ Usecase \u00b6 The tuning method included in this library as default is the CPLMFC. The process is illustrated as shown: Initializations \u00b6 C++ #include \"Arduino.h\" /* PID Library Include Files */ #include \"ModernPIDControlSS.h\" /* Global Declarations */ /* Tuning Parameters */ double wn ; float alpha ; /* Timing Information */ double L ; double ts ; double dt = 0.01 ; double t = 0.0 ; const double r = 150.0 ; double y = 0 ; int countseq = 0 ; const int umin = - 255 ; const int umax = 255 ; const int dead_max = 100 ; const int dead_min = 10 ; // zero tolerance limits /* Parameters PID Structure Config. */ PIDNet PIDobj_II ( r , y , dt , umax , umin ); Setup \u00b6 C++ void setup () { // Turn on Serial Comms. // 9600 baud is a compromise setting for easy killing of a runaway process // and very slow process Serial . begin ( 9600 ); // Can Go Up to 2M PIDobj_II . Ts = dt ; /* Parameters PID Structure Config. */ PIDobj_II . b = 1 ; // optional PIDobj_II . c = 0 ; // optional PIDobj_II . follow = 1 ; // optional /* CPLMFC Tuning HyperParameter Config. */ int Nts = 228 ; // settling horizon: set after settling-time identification ts = Nts * dt ; // settling time (including delay time) L = 0 * dt ; // estimated transport or delay time /* Hyper-Parameter for Kp and Critic Weights */ alpha = 20.0 ; // for P // for D PIDobj_II . lambdad = 0.1 ; // I PIDobj_II . lambdai = 0.5 ; /* PID Commonsense Model Config. */ /* Natural Frequency for PID Commonsense */ tuneWn ( PIDobj_II , ts , wn ); //Serial.println(wn);// debug } Settling-Time Identification Loop \u00b6 C++ ... /* SYS ID- START */ if ( sys_id == 1 ) { if ( countseq == 0 ) { ref_id = 1 * 255 ; PIDobj_II . y = 1 * 255 ; } PIDobj_II . u = ref_id - PIDobj_II . y ; // SYS ID- END } ... PID-Control Loop \u00b6 C++ ... tstart = micros () / double ( 1000000 ); t = t - tstart ; if ( t >= ( ( PIDobj_II . T_prev + PIDobj_II . Ts ) - ( 0.5 * PIDobj_II . Ts ) )) { /* CPLM Evolution */ cplm_kernel ( PIDobj_II . ym , PIDobj_II . xm , PIDobj_II . r , PIDobj_II . Ts , 0 , 0 , wn ); // Serial.print(\"ym: \"); Serial.println(PIDobj_II.ym); /* CPLMFC Tuning Computation */ tuneKp ( PIDobj_II , t , L , ts , alpha , 2 ); //Serial.print(\"Kp: \");Serial.println(PIDobj_II.Kp); tuneKi ( PIDobj_II , wn ); //Serial.print(\" Ki: \");Serial.print(PIDobj_II.Ki); tuneKd ( PIDobj_II , wn ); //Serial.print(\" Kd: \");Serial.println(PIDobj_II.Kd); /* PID Control State Evolution: Architecture */ sfunPID_kernel ( PIDobj_II , t ); //Serial.print(\"upwm_II: \"); Serial.println(PIDobj_II.u); } t = micros () / double ( 1000000 ); ... Notice \u00b6 Please, this Guide is still in a draft (beta) state. It will be updated gradually. Faq Please, feel free to contact me at oasomefun@futa.edu.ng for any questions or to report any bug.","title":"Guide"},{"location":"guide/#simplified-algorithm-for-a-modern-implementation-of-the-pid-law","text":"Although, the concept and theory of the PID is considered established by many, yet the PID law is still largely misunderstood. It is usually under-rated as a simple and old control algorithm. Quite truly, the overview representation is simple, but its design is not so. From the lens of neuroscience, the PID law is the simplest representation of active inference in nature. It is the simplest representation of the complex intelligence of inference in nature. The PID law, actively tries to minimize the deviation of the sensed behaviour from the expected behaviour. It is a law for making inference based on an expected behaviour, and a sensed behaviour. This means that the PID law is an artificial intelligence (AI) for inference. Notably, Nicolai Minorsky, who proposed the seminal theoretical representation of the PID realised this in the early nineties. An important design question is: how to represent this AI and its parameters for guaranteed stable inference (control). In systems and control, this law is used as an algorithm for robust feedback control. It infers the necessary control input u u to a dynamical system, to reach an achievable expected output r r of the dynamical system Two main problems in this AI exist. The representation, and the design of AI. Research in the control literature has mostly focused on the latter. Synopsis In this library, using modern control theory, we provide for practical use, a simple but robust realization of the PID law represented in critic form. The features implemented are compactly listed in the about page. The problem of automatic design of the PID law for control is approached from the viewpoint of the 'closed PID-loop model'. For a more technical understanding of this automatic tuning design, read the preprint at ( https://arxiv.org/pdf/2006.00314 ). Also, please see the library license for further details on library use.","title":"Simplified Algorithm for a Modern Implementation of the PID Law"},{"location":"guide/#pid-law-representation","text":"The PID Law can be represented as a critic function: u = f(r,y) u = f(r,y) $$ u=f(r,y)=\\lambda_p\\,u_p + \\lambda_i\\,u_i + \\lambda_d\\,u_d $$","title":"PID Law: Representation"},{"location":"guide/#usecase","text":"The tuning method included in this library as default is the CPLMFC. The process is illustrated as shown:","title":"Usecase"},{"location":"guide/#initializations","text":"C++ #include \"Arduino.h\" /* PID Library Include Files */ #include \"ModernPIDControlSS.h\" /* Global Declarations */ /* Tuning Parameters */ double wn ; float alpha ; /* Timing Information */ double L ; double ts ; double dt = 0.01 ; double t = 0.0 ; const double r = 150.0 ; double y = 0 ; int countseq = 0 ; const int umin = - 255 ; const int umax = 255 ; const int dead_max = 100 ; const int dead_min = 10 ; // zero tolerance limits /* Parameters PID Structure Config. */ PIDNet PIDobj_II ( r , y , dt , umax , umin );","title":"Initializations"},{"location":"guide/#setup","text":"C++ void setup () { // Turn on Serial Comms. // 9600 baud is a compromise setting for easy killing of a runaway process // and very slow process Serial . begin ( 9600 ); // Can Go Up to 2M PIDobj_II . Ts = dt ; /* Parameters PID Structure Config. */ PIDobj_II . b = 1 ; // optional PIDobj_II . c = 0 ; // optional PIDobj_II . follow = 1 ; // optional /* CPLMFC Tuning HyperParameter Config. */ int Nts = 228 ; // settling horizon: set after settling-time identification ts = Nts * dt ; // settling time (including delay time) L = 0 * dt ; // estimated transport or delay time /* Hyper-Parameter for Kp and Critic Weights */ alpha = 20.0 ; // for P // for D PIDobj_II . lambdad = 0.1 ; // I PIDobj_II . lambdai = 0.5 ; /* PID Commonsense Model Config. */ /* Natural Frequency for PID Commonsense */ tuneWn ( PIDobj_II , ts , wn ); //Serial.println(wn);// debug }","title":"Setup"},{"location":"guide/#settling-time-identification-loop","text":"C++ ... /* SYS ID- START */ if ( sys_id == 1 ) { if ( countseq == 0 ) { ref_id = 1 * 255 ; PIDobj_II . y = 1 * 255 ; } PIDobj_II . u = ref_id - PIDobj_II . y ; // SYS ID- END } ...","title":"Settling-Time Identification Loop"},{"location":"guide/#pid-control-loop","text":"C++ ... tstart = micros () / double ( 1000000 ); t = t - tstart ; if ( t >= ( ( PIDobj_II . T_prev + PIDobj_II . Ts ) - ( 0.5 * PIDobj_II . Ts ) )) { /* CPLM Evolution */ cplm_kernel ( PIDobj_II . ym , PIDobj_II . xm , PIDobj_II . r , PIDobj_II . Ts , 0 , 0 , wn ); // Serial.print(\"ym: \"); Serial.println(PIDobj_II.ym); /* CPLMFC Tuning Computation */ tuneKp ( PIDobj_II , t , L , ts , alpha , 2 ); //Serial.print(\"Kp: \");Serial.println(PIDobj_II.Kp); tuneKi ( PIDobj_II , wn ); //Serial.print(\" Ki: \");Serial.print(PIDobj_II.Ki); tuneKd ( PIDobj_II , wn ); //Serial.print(\" Kd: \");Serial.println(PIDobj_II.Kd); /* PID Control State Evolution: Architecture */ sfunPID_kernel ( PIDobj_II , t ); //Serial.print(\"upwm_II: \"); Serial.println(PIDobj_II.u); } t = micros () / double ( 1000000 ); ...","title":"PID-Control Loop"},{"location":"guide/#notice","text":"Please, this Guide is still in a draft (beta) state. It will be updated gradually. Faq Please, feel free to contact me at oasomefun@futa.edu.ng for any questions or to report any bug.","title":"Notice"},{"location":"about/about/","text":"About \u00b6 Many accounts available online, as regards the implementation of a PID controller, modify the simplified overview representation using some practical issues namely: Sampling Noisy Derivative Contributions Set-point and Derivative Kick Integral Anti-windup Bumpless Parameter Changes. However, from knowledge available in current modern control systems theory and application, these issues can be viewed as compensating for a limited view of controller representation. The design and realization of a modern controller should inherently address these issues. For example, Issue 1 is necessary for discrete-time implementation (software). Issue 2 is covered by digital signal-processing information theory in relation to Issue 1. Issue 3 is covered by the two-degree of freedom control structure. Issue 4 is covered by modern anti-windup synthesis. Issue 5 is covered by similarly treating the effect of parameter changes as a wind-up problem. In this library, the realization of the PID control algorithm addresses all these issues internally as part of the control design. It features: Simplified Bilinear Discretization for Integration and Differentiation Filtering: Information theory perspective of Signal processing Critic Contributions Two Degree-of-Freedom Control Structure Automatic Anti-windup Control Real-time Tuning: Closed PID-Loop Model Following Control Closed PID-Loop Model Following Control \u00b6 Closed PID-Loop Model Following Control is the method used to tune the PID is detailed in this paper CPLMFC . For more details on the theory, see Closed PID-Loop Model Following Control Preprint .","title":"About"},{"location":"about/about/#about","text":"Many accounts available online, as regards the implementation of a PID controller, modify the simplified overview representation using some practical issues namely: Sampling Noisy Derivative Contributions Set-point and Derivative Kick Integral Anti-windup Bumpless Parameter Changes. However, from knowledge available in current modern control systems theory and application, these issues can be viewed as compensating for a limited view of controller representation. The design and realization of a modern controller should inherently address these issues. For example, Issue 1 is necessary for discrete-time implementation (software). Issue 2 is covered by digital signal-processing information theory in relation to Issue 1. Issue 3 is covered by the two-degree of freedom control structure. Issue 4 is covered by modern anti-windup synthesis. Issue 5 is covered by similarly treating the effect of parameter changes as a wind-up problem. In this library, the realization of the PID control algorithm addresses all these issues internally as part of the control design. It features: Simplified Bilinear Discretization for Integration and Differentiation Filtering: Information theory perspective of Signal processing Critic Contributions Two Degree-of-Freedom Control Structure Automatic Anti-windup Control Real-time Tuning: Closed PID-Loop Model Following Control","title":"About"},{"location":"about/about/#closed-pid-loop-model-following-control","text":"Closed PID-Loop Model Following Control is the method used to tune the PID is detailed in this paper CPLMFC . For more details on the theory, see Closed PID-Loop Model Following Control Preprint .","title":"Closed PID-Loop Model Following Control"},{"location":"about/license/","text":"License \u00b6 MIT License Copyright \u00a9 2019-Present Oluwasegun Somefun oasomefun@futa.edu.ng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"MIT License Copyright \u00a9 2019-Present Oluwasegun Somefun oasomefun@futa.edu.ng Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"releases/release/","text":"Releases \u00b6 The following versions have so far been pushed to the Arduino library list. Changelog \u00b6 1.0 May 31, 2020 \u00b6 Initial release","title":"Release Log"},{"location":"releases/release/#releases","text":"The following versions have so far been pushed to the Arduino library list.","title":"Releases"},{"location":"releases/release/#changelog","text":"","title":"Changelog"},{"location":"releases/release/#10-may-31-2020","text":"Initial release","title":"1.0  May 31, 2020"}]}